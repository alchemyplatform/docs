---
title: 5. एक डायनेमिक NFT(एनएफटी) कैसे बनाए
subtitle: >-
  एक डायनेमिक एनएफटी बनाने का तरीका जानें जो मार्किट के डेटा के आधार पर बदलता है
  और Chainlink Oracle(चेनलिंक ऑरेकल) का उपयोग करें जो बाहरी स्रोतों से डेटा को
  स्मार्ट कॉन्ट्रैक्ट में खींचता है।
slug: docs/connect-apis-to-your-smart-contracts-using-chainlink-hindi
---


## एक डायनेमिक/गतिशील एनएफटी क्या है?

[डायनेमिक एनएफटी](https://blog.chain.link/what-is-a-dynamic-nft/) एक अपूरणीय(नॉन-फंजीबल) टोकन है जो कुछ परिस्थितियों के आधार पर बदल सकता है।

उदाहरण के लिए, वर्तमान में आठ अलग-अलग [LaMelo Ball NFTs(लामेलो बॉल एनएफटीस)](https://lameloball.io/#/) हैं, प्रत्येक एनएफटी में LaMelo के खिलाड़ी के आंकड़ों का एक अलग सेट रिकॉर्ड किया जा रहा है, जिसमें रिबाउंड्स(rebounds) और असिस्ट(assists) से लेकर पॉइंट्स शामिल हैं, और इनके आधार पर बदलते हैं (10 असिस्ट? अलग रंग - 1 पॉइंट स्कोर, अलग बॉल ).

डायनेमिक एनएफटी धारक/होल्डर लामेलो के चल रहे प्रदर्शन के आधार पर रैफल्स(raffles) और अन्य एनएफटी-विशिष्ट भत्तों(perks) तक विशेष पहुंच प्राप्त कर सकते हैं।

यह अभी और भी अच्छा होगा;

इन आठ एनएफटी में से एक, गोल्ड इवॉल्व एनएफटी(Gold Evolve NFT), एक अनोखे वादे के साथ आया:

यदि लामेलो बॉल ने 2021 एनबीए सीज़न के लिए रूकी ऑफ द ईयर जीता, तो एनएफटी स्वयं एक नई छवि को दर्शाने के लिए विकसित होगा। LaMelo ने पुरस्कार जीता और एनएफटी विकसित(evolved ) हुआ।

![2000](/images/2e7a9fc-image.png "image.png")

चलिए ट्यूटोरियल शुरू करते हैं।

## इस डायनामिक एनएफ

इस ट्यूटोरियल में, आप एसेट प्राइस डेटा प्राप्त करने और ट्रैक करने के लिए [Chainlink(चैनलिंक) के विकेंद्रीकृत(decentralized) और क्रिप्टोग्राफ़िक रूप से सुरक्षित ऑरेकल नेटवर्क ](https://chain.link/)का उपयोग करके एक डायनेमिक एनएफटी बनाने जा रहे हैं।

फिर, आप [Chainlink Keepers Network(चेनलिंक कीपर्स नेटवर्क)](https://docs.chain.link/docs/chainlink-keepers/introduction/) से ऑटोमेशन का उपयोग करेंगे अपने एनएफटी स्मार्ट कॉन्ट्रैक्ट को स्वचालित करके ट्रैक किए जा रहे परिसंपत्ति मूल्य डेटा(asset price data) के अनुसार एनएफटी को अपडेट करेंगे ।

यदि मार्किट/बाजार मूल्य बढ़ता है, तो स्मार्ट कॉन्ट्रैक्ट यादृच्छिक रूप से(randomly) इन तीन बुलिश इमेजेज(Bullish Images) में से एक को इंगित करने के लिए एनएफटी के यूआरआई को चुन लेगा और एनएफटी को डायनामिक रूप से अपडेट किया जाएगा:

![2000](/images/377ea23-image_1.png "image (1).png") ![2000](/images/f5b5af8-image_2.png "image (2).png") ![2000](/images/5276bad-image_3.png "image (3).png")

यदि मूल्य फ़ीड का डेटा नीचे चला जाता है, तो एनएफटी गतिशील रूप से इन मंदी(Bearish/बेयरिश) की छवियों में से एक को अपडेट करेगा, जो भी यादृच्छिक रूप(randomly) से चुनी गई हैं!

![2000](/images/faf2f11-image_4.png "image (4).png") ![2000](/images/12aba4a-image_5.png "image (5).png") ![2000](/images/6012e82-image_6.png "image (6).png")

(क्रेडिट: चैनलिंक डिजाइन टीम)

अंत में हम [Chainlink’s Verifiable Random Function(चैनलिंक के सत्यापन योग्य रैंडम फ़ंक्शन)](https://docs.chain.link/docs/chainlink-vrf/) का उपयोग करेंगे ताकि क्रिप्टोग्राफिक रूप से गारंटीकृत यादृच्छिकता(randomness) को हमारे एनएफटी स्मार्ट कॉन्ट्रैक्ट में जोड़ सकें और विकल्पों की सूची से रैंडमली एनएफटी छवि का चयन कर सकें।

<Info>
  [यदि आप चीज़ों को देख कर अच्छे से सीखते हैं, तो आप एल्केमी यूट्यूब चैनल से चैनलिंक का उपयोग करके एपीआई को स्मार्ट कॉन्ट्रैक्ट्स से कैसे जोड़ा जाए, इस पर पूर्ण वीडियो ट्यूटोरियल को देख सकते हैं।](https://www.youtube.com/watch?v=hNdXSMKLDi4)
</Info>

आइए हैक करें!

## आवश्यक टूल्स और पूर्वापेक्षाएँ(prerequisites)

यह ट्यूटोरियल मानता है कि आपके पास कुछ पूर्व कोडिंग का अनुभव है और आपने [Welcome to the Road to Web3 (वेलकम टू द रोड टू वेब3)](/docs/welcome-to-the-road-to-web3) प्रोग्राम की पूर्ववर्ती कॉन्टेंट (preceding content) का पालन किया है जिसे [अल्केमी](https://alchemy.com/?a=6b90d91edc) ने आपके लिए बनाया है।

### 1. IDE(आईडीई)

इस ट्यूटोरियल में, हम [Remix IDE(रीमिक्स आईडीई)](https://remix.ethereum.org/) और बिल्ट-इन "London VM" ब्लॉकचेन नेटवर्क का उपयोग करने जा रहे हैं, लेकिन इसे Hardhat(हार्डहट) या किसी अन्य सॉलिडिटी स्मार्ट कॉन्ट्रैक्ट डेवलपमेंट फ्रेमवर्क और आपके पसंदीदा कोड एडिटर का उपयोग करके भी किया जा सकता है।

### 2. GitHub Repo(गीटहब रेपो)

यहां, [डायनेमिक NFT ट्यूटोरियल के लिए एक Github रेपो](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy) है जो हमने आपके लिए बनाया है।

रेपो उस संरचना/स्ट्रक्चर को दर्शाता है जिसका हम पालन करेंगे।

### The main branch(मुख्य ब्रांच)

`main` ब्रांच में [OpenZeppelin Wizard](https://docs.openzeppelin.com/contracts/4.x/wizard) का उपयोग करके बनाया गया बेसलाइन ERC721 टोकन है।

### The price-feeds branch(मूल्य-फ़ीड ब्रांच)

`price-feeds` ब्रांच Chainlink Keepers implementation (चैनलिंक कीपर्स इंप्लीमेंटेशन) को जोड़ती है और चैनलिंक एसेट मूल्य डेटा से जुड़ती है जिसका उपयोग हम किसी विशिष्ट एसेट की कीमत को ट्रैक करने के लिए करेंगे।

### The randomness branch(रेंडमनेस ब्रांच)

`randomess` शाखा में रेंडमनेस जोड़ने का तर्क(logic) है ताकि हमारे डायनेमिक एनएफटी को हमारे स्मार्ट कॉन्ट्रैक्ट में मौजूद एनएफटी मेटाडेटा यूआरआई (NFT Metadata URIs) से रैंडम्ली/यादृच्छिक रूप से चुना जाए।

आपको इसे अपने कौशल का निर्माण करने के लिए एक विशेष असाइनमेंट के रूप में करना है!

### 3. IPFS Companion(आईपीएफएस सहयोगी)

[IPFS Companion Browser Extension(आईपीएफएस \*\*\*\*सहयोगी ब्राउज़र एक्सटेंशन)](https://chrome.google.com/webstore/detail/ipfs-companion/nibjojkomfdiaoajekhjakgkdhaomnch?hl=en) इनस्टॉल करें (किसी भी क्रोमियम आधारित ब्राउज़र के लिए)।

यह आपके टोकन की यूआरआई और मेटाडेटा जानकारी को होल्ड करेगा।

### 4. फॉसेट और टेस्टनेट टोकन

सुनिश्चित करें कि आपका मेटामास्क वॉलेट [Rinkeby(रिंकीबी) से जुड़ा है](https://www.alchemy.com/overviews/rinkeby-testnet#testnet-3)।

एक बार जब आपका वॉलेट रिंकीबी से जुड़ जाता है, तो [एल्केमी के रिंकीबी फॉसेट से रिंकीबी ईटीएच(Rinkeby ETH) प्राप्त करें](https://rinkebyfaucet.com/)।

आपको [टेस्टनेट लिंक टोकंस (testnet Link tokens)](https://faucets.chain.link/) प्राप्त करने की भी आवश्यकता होगी।

अपने असाइनमेंट के लिए, आप रेंडमनेस जोड़ेंगे, लेकिन आप इथीरीयम के गोएर्ली टेस्टनेट पर डेप्लॉय करेंगे।

यदि आपको गोएर्ली टेस्टनेट टोकन की आवश्यकता है, [तो एल्केमी के गोएर्ली फॉसेट से गोएर्ली इथर प्राप्त करें](https://goerlifaucet.com/)।

## 1. ERC721 टोकन सेट अप करें

हम एनएफटी स्मार्ट कॉन्ट्रैक्ट बनाने के लिए OpenZeppelin और Remix के साथ शुरुआत करेंगे।

जैसा कि यह पहले ही बताया जा चुका है, आपके पास अपना एनएफटी स्मार्ट कॉन्ट्रैक्ट प्राप्त करने के लिए दो विकल्प हैं:

### i. स्क्रैच से कॉन्ट्रैक्ट बनाएं

[Welcome to the Road to Web3(वेलकम टू द रोड टू वेब3)](/docs/welcome-to-the-road-to-web3) को फॉलो करें और एनएफटी का नाम "Bull\&Bear" रखना याद रखें।

फिर इसके सिंबल का नाम "BBTK" दें और `mintToken()` लॉजिक को अपडेट करने के लिए नीचे दिए गए कोड को ध्यान से पढ़ें!

![2000](/images/cdc7413-image_7.png "image (7).png")

### ii. GitHub Repo(गीटहब रेपो) से स्मार्ट कॉन्ट्रैक्ट कोड कॉपी करें

यह शायद सबसे तेज़ तरीका है: रेपो की मुख्य शाखा (main branch) से [स्मार्ट कॉन्ट्रैक्ट कोड को कॉपी करें](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/main/contracts/Bull%26Bear.sol) और इसे रीमिक्स में `Bull&Bear.sol` के रूप में सेव करें।

ध्यान दें कि हमने आईपीएफएस यूआरआई(IPFS URI) के ऐरे/सरणी के रेफ़्रेन्स(संदर्भ) कैसे जोड़े हैं और `safeMint()` मेथड को भी अपडेट किया है ताकि शुरुआती बिंदु (as a staring point) के रूप में प्रारंभिक टोकन यूआरआई को सेट कर सकें।

## 2. IPFS URIs में लिंक्स को अपडेट करें

अब आपको यह सुनिश्चित करने की आवश्यकता है कि आप आईपीएफएस यूआरआई में `bullUrisIpfs` और `bearUrisIpfs` के लिए लिंक्स अपडेट करें ताकि यह आपके द्वारा IPFS ब्राउज़र नोड पर होस्ट की गई फ़ाइलों को पॉइंट करे।

अपने ब्राउज़र IPFS नोड पर NFT डेटा सेट करने के लिए:

* [रेपो में इस फ़ोल्डर से](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/tree/main/ipfs) टोकन मेटाडेटा JSON और इमेज फ़ाइलों को कॉपी करें
* अपने local IPFS नोड को खोलने के लिए IPFS Companion के ब्राउज़र एक्सटेंशन आइकन पर क्लिक करें
* उन सभी फाइलों को अपने नोड के FILES सेक्शन में इम्पोर्ट करें
* URI लिंक प्राप्त करने के लिए, तीन बिंदुओं पर क्लिक करें और "Share Link" से स्ट्रिंग कॉपी करें।

![1600](/images/a26971b-Untitled_10.png "Untitled (10).png")

<Info>
  आपको अपने IPFS node (आईपीएफएस नोड) में JSONs (जेएसओएन) और PNGs(पीएनजी) दोनों की आवश्यकता होगी, लेकिन आपके स्मार्ट कॉन्ट्रैक्ट के लिए केवल जेएसओएन फाइलें क्योंकि जेएसओएन फाइलें पीएनजी को पॉइंट करती हैं।
</Info>

## 3. Compile check (संकलन जांच) पूरी करें

* स्मार्ट कॉन्ट्रैक्ट pragma (0.8.0 आगे) के आधार पर रीमिक्स में सही कंपाइलर चुनें
* सुनिश्चित करें कि आप सही फ़ाइल कंपाइल/संकलित कर रहे हैं- Bull\&Bear.sol
* Javascript VM London environment in-browser (जावास्क्रिप्ट वीएम लंदन एनवायरनमेंट इन-ब्राउज़र) में अपना कॉन्ट्रैक्ट डेप्लॉय करें
* अपने रीमिक्स द्वारा प्रदान किए गए वॉलेट पते को कॉपी करें और टोकन मिंट करने के लिए इसे `safeMint` फ़ील्ड में डाले

![298](/images/fb2f522-Untitled_11.png "Untitled (11).png")

* नीचे स्क्रॉल करें और "0" आर्गुमेंट वाले tokenURI पर क्लिक करें।

![291](/images/15ec3f5-Untitled_12.png "Untitled (12).png")

बढ़िया - आपका एनएफटी स्मार्ट कॉन्ट्रैक्ट काम कर रहा है!

## 4. अपने कॉन्ट्रैक्ट keepers को कम्पेटिबल बनाएं

अब, हम अपने एनएफटी कॉन्ट्रैक्ट को न केवल डायनेमिक बल्कि स्वचालित (automatic) रूप से डायनेमिक बना सकते हैं!

यह कोड [price-feeds branch](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/tree/price-feeds) की रेपो में संदर्भित (referenced) है।

सबसे पहले, हम Chainlink Keepers (चैनलिंक कीपर्स) के साथ ऑटोमेशन लेयर जोडेंगे, जिसका अर्थ है कि हमें अपने एनएफटी स्मार्ट कॉन्ट्रैक्ट को "Keepers Compatible"(कीपर्स कम्पेटिबल) बनाने के लिए विस्तारित (extend) करने की आवश्यकता है।

## यह प्रमुख चरण हैं:

1. इम्पोर्ट "@chainlink/contracts/src/v0.8/KeeperCompatible.sol”
2. अपने कॉन्ट्रैक्ट को `KeeperCompatibleInterface` से inherit(प्राप्त) करें
3. एक interval period (अंतराल अवधि) लेने के लिए अपने कन्स्ट्रक्टर को एडजस्ट करें जो एक कॉन्ट्रैक्ट स्टेट के रूप में सेट हो जाता है और यह अंतराल सेट करता है जिस पर स्वचालन (automation) होगा।
4. एनएफटी स्मार्ट कॉन्ट्रैक्ट में `checkUpkeep` और `PerformUpkeep` फ़ंक्शंस को लागू करें ताकि हम इंटरफ़ेस को satisfy (संतुष्ट) कर सकें।
5. चैनलिंक कीपर नेटवर्क के साथ ["upkeep" कॉन्ट्रैक्ट पंजीकृत(register) करें](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/)।

चेनलिंक कीपर्स नेटवर्क हमारे `checkUpkeep()` फ़ंक्शन को चेक करेगा हर बार जब ब्लॉकचेन में एक नया ब्लॉक जुड़ेगा और हमारे फ़ंक्शन के अनुकरण (simulation) का ऑफ-चेन निष्पादन (execution) करेगा!

## वह फ़ंक्शन एक बूलियन लौटाता है:

* अगर यह false रिटर्न करता है, तो इसका मतलब है कि अभी तक कोई स्वचालित upkeep देय नहीं है।
* अगर यह true रिटर्न करता है, तो इसका मतलब है कि हमारे द्वारा सेट किया गया `interval` बीत चुका है, और एक upkeep action बाकी है।

कीपर्स नेटवर्क हमारे `performUpkeep()` फ़ंक्शन को स्वचालित रूप से कॉल करता है, और लॉजिक ऑन-चेन चलाता है।

किसी डेवलपर एक्शन की आवश्यकता नहीं है।

यह जादू जैसा है!

हमारा `checkUpkeep` सीधा साधा होगा क्योंकि हम केवल यह जांचना चाहते हैं कि क्या `interval` (अंतराल) समाप्त हो गया है और उस बूलियन को वापस कर देना, लेकिन हमारे `performUpkeep` को एक price feed (मूल्य फ़ीड) की जांच करने की आवश्यकता है।

उसके लिए, हमें अपने स्मार्ट कॉन्ट्रैक्ट को Chainlink Price Feed Oracles (चैनलिंक्स प्राइस फीड ऑरेकल्स) के साथ इंटरैक्ट करने की आवश्यकता है।

हम [रिंकीबी पर BTC/USD फ़ीड प्रॉक्सी कॉन्ट्रैक्ट](https://rinkeby.etherscan.io/address/0xECe365B379E1dD183B20fc5f022230C044d51404) का उपयोग करेंगे, लेकिन आप रिंकीबी नेटवर्क से [किसी अन्य को चुन सकते हैं](https://docs.chain.link/docs/ethereum-addresses/)।

## 5. चैनलिंक प्राइस फीड्स के साथ इंटरैक्ट करें

पसंद के प्राइस फीड ऑरेकल के साथ इंटरैक्ट करने के लिए, हमें `AggregatorV3Interface` का उपयोग करने की आवश्यकता है।

<Info>
  [यह समझना सुनिश्चित करें कि डेटा फ़ीड कैसे काम करते हैं और उनका उपयोग कैसे करें।](https://docs.chain.link/docs/get-the-latest-price/)
</Info>

`[price-feeds` शाखा में हमारे रेफ़्रेन्स/संदर्भ कोड में]\([https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/Bull\&Bear.sol](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/Bull\&Bear.sol)), कंस्ट्रक्टर एग्रीगेटर ऑरेकल के पते को एक पैरामीटर के रूप में स्वीकार करता है। डिप्लॉयमेंट के समय एक पैरामीटर को स्वीकार करना बहुत उपयोगी है क्योंकि जब हम स्थानीय रूप से डिप्लॉय करते हैं (when we deploy locally) तो यह इसे कॉन्फ़िगर करने योग्य बनाता है।

रिंकीबी पर लाइव ऑरेकल के साथ इंटरैक्ट करने के लिए, हमारे कॉन्ट्रैक्ट को रिंकीबी पर डेप्लॉय करने की आवश्यकता है। एकीकरण परीक्षण (integration testing) के लिए यह आवश्यक है लेकिन इसे विकसित करते समय यह हमें थोड़ा धीमा कर देता है।

हम लोकल edit-compile-debug (एडिट-कम्पाइल-डीबग) डेवलपमेंट साइकिल की गति कैसे बढ़ा सकते हैं?

### लाइव नेट स्मार्ट कॉन्ट्रैक्ट्स को मॉक (mock) करना

परीक्षण नेटवर्क जैसे रिंकीबी में लगातार पुनः डिप्लॉयमेंट के बजाय, परीक्षण इथर (ETH) का भुगतान करना, आदि , हम (अपने स्मार्ट कॉन्ट्रैक्ट पर पुनरावृति करते समय) [mocks(मॉकस)](https://en.wikipedia.org/wiki/Mock_object) का उपयोग कर सकते हैं।

उदाहरण के लिए [हम इस मॉक प्राइस फीड कॉन्ट्रैक्ट](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/MockPriceFeed.sol) का उपयोग करके प्राइस फीड एग्रीगेटर कॉन्ट्रैक्ट मॉक कर सकते हैं।

इसका फायदा यह है कि हम मॉक को अपने रीमिक्स, इन-ब्राउज़र London VM environment (लंदन वीएम एनवायरनमेंट) में डिप्लॉय कर सकते हैं और विभिन्न परिदृश्यों का परीक्षण करने के लिए इसके रिटर्न के मूल्यों को समायोजित (एडजस्ट) कर सकते हैं, लाइव नेटवर्क पर नए कॉन्ट्रैक्ट्स को लगातार डिप्लॉय किए बिना, फिर मेटामास्क के माध्यम से हर बार लेनदेन को मंजूरी दें और ETH का भुगतान करें।

### यहाँ क्या करना है:

* उस फाइल को अपने रीमिक्स पर कॉपी करें
* इसे `MockPriceFeed` के रूप में सेव करें
* इसे डिप्लॉय करें

यह केवल [मॉक आयात कर रहा है जिसे चैनलिंक](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/tests/MockV3Aggregator.sol) ने प्राइस फीड एग्रीगेटर प्रॉक्सी के लिए लिखा है।

<Info>
  टिप्पणी इस मॉक को कंपाइल करने के लिए आपको कंपाइलर को 0.6.x में बदलना होगा।
</Info>

मॉक को डिप्लॉय करते समय आपको दशमलव (decimals) में पास करने की आवश्यकता होती है, जिसके साथ मूल्य फ़ीड कीमतों को कैलकुलेट करेगा।

आप "Show More Details" पर क्लिक करने के बाद, [list of price feed contract address(मूल्य फ़ीड कॉन्ट्रैक्ट पतों की सूची)](https://docs.chain.link/docs/ethereum-addresses/) से इन्हें प्राप्त कर सकते हैं।

![1600](/images/569b2a2-Untitled_13.png "Untitled (13).png")

BTC/USD फीड 8 डेसीमल लेता है।

आपको फ़ीड के शुरुआती मूल्य (initial value) को भी पास करना होगा।

चूंकि हमने यादृच्छिक रूप से (randomly) BTC/USD एसेट प्राइस चुना है, हमने परीक्षण करते समय इसे एक पुराना मूल्य दिया: `3034715771688`

<Info>
  जब आप इसे स्थानीय रूप से परिनियोजित करते हैं, तो रीमिक्स आपको जो कॉन्ट्रैक्ट पता देता है उसे नोट करना सुनिश्चित करें।

  यह वही है जो आप अपने एनएफटी स्मार्ट कॉन्ट्रैक्ट के कंस्ट्रक्टर में पास करते हैं ताकि यह मॉक को प्राइस फीड के रूप में इस्तेमाल कर सके।
</Info>

![326](/images/fc9392a-Untitled_14.png "Untitled (14).png")

आपको अपने स्थानीय रूप से परिनियोजित मॉक प्राइस फीड (locally deployed mock price feed) के साथ भी खेलना चाहिए।

मॉक प्राइस फीड से लेटेस्ट प्राइस और [चेनलिंक प्राइस फीड एपीआई(Chainlink Price Feed API)](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) के अनुरूप अन्य डेटा देखने के लिए `latestRoundData` को कॉल करें।

आप `updateAnswer` पर कॉल करके और उच्च या निम्न वैल्यू (कीमतों में वृद्धि और गिरावट को सिमुलेट करने के लिए) में मूल्य/प्राइस को अपडेट कर सकते हैं।

आप `2534715771688` पास करके प्राइस में गिरावट या `4534715771688` पास करके प्राइस में वृद्धि कर सकते हैं।

आपके एनएफटी स्मार्ट कॉन्ट्रैक्ट के इन-ब्राउज़र परीक्षण के लिए बहुत आसान!

एनएफटी स्मार्ट कॉन्ट्रैक्ट पर वापस जा रहे हैं, [रेफ़्रेन्स कोड](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/Bull%26Bear.sol) को दर्शाने के लिए इसे अपडेट करना सुनिश्चित करें।

### तो यहाँ हमारा सुझाव है कि आप क्या करें:

1. पहले इस संक्षिप्त दस्तावेज़ को पढ़ें कि [कैसे हमारे NFT स्मार्ट कॉन्ट्रैक्ट को कीपर्स कम्पेटिबल बनाया जाए](https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/)
2. [डेटा फ़ीड का उपयोग करने का सरल तरीका](https://docs.chain.link/docs/get-the-latest-price/) पढ़ें
3. [मॉक डेटा फ़ीड](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/MockPriceFeed.sol) डिप्लॉय करें
4. चैनलिंक प्राइस फीड स्मार्ट कॉन्ट्रैक्ट कैसे लिखे जाते हैं, यह समझने के लिए इसका [सोर्स कोड पढ़ें](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/tests/MockV3Aggregator.sol)

एक बार जब आप इन संसाधनों (resources) को पढ़ लेते हैं, तो इसे स्वयं आज़माएँ।

यदि आप सीधे हमारे कार्यान्वयन (implementation) पर जाना चाहते हैं, तो यह price-feeds शाखा पर है।

ध्यान दें कि हम `price feed` को एक public state variable (सार्वजनिक स्टेट वेरिएबल) के रूप में सेट करते हैं ताकि हम इसे हेल्पर मेथड का उपयोग करके बदल सकें `setPriceFeed()` , और हमने प्रदर्शन करने के लिए प्रमुख डायनेमिक NFT लॉजिक/तर्क भी `performUpkeep()` में जोड़ा।

हर बार जब चैनलिंक कीपर्स नेटवर्क उसे कॉल करता है, तो यह उस लॉजिक को ऑन-चेन एक्सीक्यूट/निष्पादित करेगा और अगर चैनलिंक प्राइस फीड हमारे द्वारा पिछली बार ट्रैक की गई कीमत से अलग कीमत की रिपोर्ट करता है, तो यूआरआई (URIs) अपडेट हो जाते हैं।

<Info>
  यह डेमो स्मार्ट कॉन्ट्रैक्ट में सभी टोकन यूआरआई को अपडेट करने की गैस लागत के लिए ऑप्टिमाइज़ नहीं है। हम इस बात पर ध्यान केंद्रित करते हैं कि एनएफटी को कैसे डायनेमिक बनाया जा सकता है।

  संचलन में मौजूद सभी एनएफटी को अपडेट करने की लागत इथीरियम नेटवर्क पर बहुत अधिक हो सकती है, इसलिए सावधानी से विचार करें, और गैस शुल्क का अनुकूलन करने के लिए layer 2 समाधान या अन्य आर्किटेक्चर को एक्स्प्लोर करें।
</Info>

## वर्कफ़्लो का सारांश(Summarizing the workflow)

जब आप यह सब कर लेंगे, तो आपका परीक्षण कार्यप्रवाह कुछ ऐसा दिखाई देगा:

#### 1) मॉक प्राइस फीड को रीमिक्स पर तैनात करें

प्रारंभ करने और उसका पता कॉपी करने के लिए आप कंस्ट्रक्टर तर्क `8,3034715771688` का उपयोग कर सकते हैं।

<Info>
  इसके लिए रीमिक्स कंपाइलर को 0.6.x रेंज में सेट करना याद रखें।
</Info>

#### 2) Bull\&Bear स्मार्ट टोकन कॉन्ट्रैक्ट को फिर से डिप्लॉय करें

<Info>
  कंपाइलर संस्करण को अपडेट करना याद रखें।
</Info>

कन्स्ट्रक्टर आर्ग्यूमेंट्स के लिए, आप 10 सेकंड अंतराल के लिए और मॉक प्राइस फ़ीड के पते को दूसरे तर्क के रूप में पास कर सकते हैं।

#### 3) एक या दो टोकन मिंट करें

एक या दो टोकन मिंट करें और 0, 1, या आपके पास जो भी मिंटेड टोकन आईडी है, उसे पास करने के बाद `tokenURI` पर क्लिक करके उनके `tokenURIs` की जांच करें।

सभी टोकन यूआरआई का डिफ़ॉल्ट `gamer_bull.json` होना चाहिए।

#### 4) एनएफटी कॉन्ट्रैक्ट के कंस्ट्रक्टर की जाँच करें

जांचें कि NFT कॉन्ट्रैक्ट के कंस्ट्रक्टर को `getLatestPrice()` कहा जा रहा है और बदले में `currentPrice` स्टेट वेरिएबल को अपडेट करता है।

`currentPrice` बटन पर क्लिक करके ऐसा करें - परिणाम (result) आपके मॉक प्राइस फीड में सेट की गई कीमत से मेल खाना चाहिए।

#### 5) एक खाली(ऐरे) सरणी में पास करें

`checkUpkeep` पर क्लिक करें और आर्ग्यूमेंट के रूप में खाली ऐरे (`[]`) पास करें। इसे true बूलियन लौटाना चाहिए क्योंकि हम `interval` अवधि के रूप में 10 सेकंड पास किये हैं और 10 सेकंड बीत चुके होंगे जब आपने `Bull&Bear` को तैनात किया था।

आपकी सुविधा के लिए [संदर्भ(reference) रेपो में एक सेटर फ़ंक्शन शामिल है](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/price-feeds/contracts/Bull%26Bear.sol#L156) ताकि आप अंतराल (interval) फ़ील्ड को अपडेट कर सकें।

<Info>
  ध्यान रखें कि जब आप Rinkeby पर डिप्लॉय करते हैं तो आप अंतराल (interval) को लंबे समय तक सेट करना चाहेंगे - प्रत्येक फ़ीड कॉन्फ़िगर किए गए अंतराल पर या यदि मूल्य निर्धारित सीमा से विचलन (deviates) करता है तो इसकी समेकित कीमतों(aggregated prices) को अपडेट करता है।

  यदि आप अपने कीपर्स चेक को कम समय में बहुत बार कॉन्फ़िगर करते हैं, तो यह आपके परीक्षण लिंक (test LINK) टोकन की बर्बादी होगी।

  यही कारण है कि मॉकिंग के लिए हम इसे 10 सेकंड के एक बहुत ही कम अंतराल में पास करते हैं, क्योंकि हम परीक्षण लिंक खर्च नहीं करते हैं, और इसलिए भी कि हम जल्दी से `PerformUpkeep()` चला सकते हैं।
</Info>

#### 6) सुनिश्चित करें कि मॉक प्राइस फीड अपडेटेड है

सुनिश्चित करें कि आपकी मॉक प्राइस फीड एक ऐसी कीमत वापस करने के लिए अपडेट की गई है जो वर्तमान में आपके एनएफटी स्मार्ट कॉन्ट्रैक्ट के `currentPrice` में संग्रहीत मूल्य से भिन्न है।

उदाहरण के लिए, यदि आप मॉक कॉन्ट्रैक्ट को कम संख्या के साथ अपडेट करते हैं, आप उम्मीद करेंगे कि आपका एनएफटी स्मार्ट कॉन्ट्रैक्ट एनएफटी को "bear" टोकन यूआरआई दिखाने के लिए स्विच करेगा।

#### 7) अपने कॉन्ट्रैक्ट को बुलाए जाने का अनुकरण (simulation) करें

एक खाली ऐरे पास करने के बाद `PerformUpkeep` पर क्लिक करें। इस तरह आप रिंकबी पर चैनलिंक कीपर्स नेटवर्क द्वारा बुलाए जा रहे अपने कॉन्ट्रैक्ट का अनुकरण करते हैं।

भूलिए नहीं, अपने असाइनमेंट के हिस्से के रूप में आपको रिंकीबी में डिप्लॉय करने का मौका मिलता है और आप [upkeep को पंजीकृत करते हैं](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/) और रिंकीबी प्राइस फीड से जुड़ते हैं।

चूँकि अभी हम रीमिक्स इन-ब्राउज़र नेटवर्क पर हैं, इसलिए हमें स्वंय `performUpkeep` को कॉल करके ऑटोमेशन प्रवाह का अनुकरण (simulation) करने की आवश्यकता है

#### 8) नवीनतम कीमत की जांच करें और सभी टोकन यूआरआई को अपडेट करें

`performUpkeep` को नवीनतम मूल्य की जांच करनी चाहिए और सभी टोकन URI को अपडेट करना चाहिए।

<Info>
  यह रीमिक्स ब्राउज़र में तात्कालिक है। रिंकीबी पर इसमें कुछ समय लग सकता है।
</Info>

स्थानीय रूप से (locally) करते समय आपको मेटामास्क में किसी भी लेन-देन पर हस्ताक्षर करने की आवश्यकता नहीं है, लेकिन जब आप रिंकीबी से जुड़ते हैं तो मेटामास्क आप से प्रत्येक चरण के लिए लेनदेन (transaction) पर हस्ताक्षर करने के लिए कहेगा।

#### 9) `currentPrice` को रिफ्रेश करें और `tokenURI` को चेक करें

यदि आप `currentPrice` पर क्लिक करते हैं तो आपको अपडेटेड मॉक प्राइस फीड के आधार पर कीमत (price) दिखनी चाहिए।

`tokenURI` पर फिर से क्लिक करें, और आपको देखना चाहिए कि आपका टोकन URI बदल गया है।

यदि कीमत पिछले स्तर से नीचे गिरती है तो इसे bear में बदल दिया जाएगा।

यदि अंतिम टोकन URI एक bear(भालू) था और कीमत बढ़ गई, तो उसे एक bull(बैल) टोकन URI में बदल जाना चाहिए।

## सप्ताह 5 का असाइनमेंट

यह असाइनमेंट एक नए टूल का उपयोग करता है: Chainlink Verifiable Random Function(चैनलिंक वेरिफिएबल रैंडम फंक्शन)।

यह टूल क्रिप्टोग्राफ़िक रूप से साबित करने योग्य randomness(यादृच्छिकता) प्रदान करता है और व्यापक रूप से गेमिंग और अन्य अनुप्रयोगों में उपयोग किया जाता है जहां उचित परिणामों के लिए provable and tamper-resistant randomness (सिद्ध और छेड़छाड़-प्रतिरोधी यादृच्छिकता) आवश्यक है।

अभी, हमारे यह पास हार्ड कोडेड है की कौन सा टोकन यूआरआई दिखाई देगा - सरणी(array) में पहला यूआरआई (इंडेक्स 0)। हमें इसे एक यादृच्छिक सूचकांक संख्या(random index number) बनाने की आवश्यकता है ताकि एक यादृच्छिक(random) एनएफटी छवि टोकन यूआरआई के रूप में दिखाई दे।

## यहाँ कदम हैं(here are the steps):

### 1) चैनलिंक वीआरएफ(ChainLink VRF) उदाहरण की समीक्षा करें

[चैनलिंक वीआरएफ के सुपर संक्षिप्त उदाहरण के उपयोग](https://docs.chain.link/docs/get-a-random-number/) को देखें - आपको एनएफटी स्मार्ट कॉन्ट्रैक्ट के अंदर क्रिप्टोग्राफिक रूप से साबित करने योग्य यादृच्छिकता(randomness) प्राप्त करने के लिए केवल दो फंक्शन्स को लागू करना होगा।

### 2) दो वीआरएफ फंक्शन का उपयोग करने के लिए अपने एनएफटी स्मार्ट कॉन्ट्रैक्ट को अपडेट करें

`requestRandomWords` और `fulfillRandomWords` का उपयोग करने के लिए अपने NFT स्मार्ट कॉन्ट्रैक्ट को अपडेट करें

### 3) यादृच्छिकता शाखा(randomness branch) में वीआरएफ मॉक का प्रयोग करें

reference(संदर्भ) रेपो की randomness branch में प्रदान किए गए [वीआरएफ मॉक](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/blob/randomness/contracts/MockVRFCoordinator.sol) का उपयोग करें, और सुनिश्चित करें कि आपने वीआरएफ मॉक में commented out instructions(टिप्पणी किए गए निर्देशों) को ध्यान से पढ़ा है ताकि आप जान सकें कि इसका उपयोग कैसे करना है।

## रिंकीबी पर अपना डायनेमिक एनएफटी डिप्लॉय करें

अंत में, एक बार जब आप एनएफटी स्मार्ट कॉन्ट्रैक्ट के साथ खेल चुके हैं और रीमिक्स में कुछ बार गतिशील रूप से टोकन बदलने के लिए मिला है, तो मेटामास्क और रीमिक्स को रिंकीबी से कनेक्ट करें और एनएफटी को तैनात करें।

<Info>
  जब आप NFT को रिंकीबी में तैनात करते हैं, तब भी आप मॉक का उपयोग कर सकते हैं, लेकिन आपको उन्हें भी सही क्रम में तैनात करने की आवश्यकता है।
</Info>

निम्नलिखित को सही क्रम में पूरा कीजिए:

#### 1) अपने मेटामास्क को रिंकीबी से कनेक्ट करें

#### 2) [चैनलिंक फॉसेट](https://faucets.chain.link/) \*\* से परीक्षण लिंक(test LINK) प्राप्त करें और ETH का परीक्षण करें

यदि आप मॉक प्राइस फीड एग्रीगेटर को डिप्लॉय (deploy) करने की योजना बना रहे हैं और बाद में इसे चैनलिंक रिंकीबी प्राइस फीड में अपडेट करेंगे, तो मॉक को अभी तैनात करें। इसी तरह, यदि आप मॉक वीआरएफ कोऑर्डिनेटर का उपयोग करके रिंकीबी पर परीक्षण करना चाहते हैं, तो आपको इसे रिंकीबी पर तैनात करना होगा।

#### 3) NFT स्मार्ट कॉन्ट्रैक्ट को रिंकीबी में डिप्लॉय करें

सुनिश्चित करें कि आप सही कन्स्ट्रक्टर पैरामीटर पास कर रहे हैं।

यदि आप मॉक का उपयोग कर रहे हैं, तो सुनिश्चित करें कि वे पहले डिप्लॉय किए गए हैं ताकि आप उनके रिंकीबी पते एनएफटी कॉन्ट्रैक्ट के कन्स्ट्रक्टर को पास कर सकें।

यदि आप एक चैनलिंक लाइव प्राइस फीड का उपयोग कर रहे हैं, तो इसका पता रेफरेंस रेपो या जो भी रिंकीबी प्राइस फीड एड्रेस आप [यहां से चुनते हैं](https://docs.chain.link/docs/ethereum-addresses/), के अनुसार होना चाहिए।

चूंकि आप अपने रीमिक्स "environment" को रिंकीबी पर तैनात एनएफटी कॉन्ट्रैक्ट से जोड़ सकते हैं, और एनएफटी कॉन्ट्रैक्ट `performUpkeep` को रीमिक्स से कॉल कर सकते हैं, आप पहले टेस्ट रन के लिए अंतराल (interval) को छोटा रख सकते हैं।

<Info>
  याद रखें कि `setInterval` को कॉल करके अंतराल को बढ़ाएं अन्यथा कीपर्स नेटवर्क आपके `performUpkeep` को जितना कि मूल्य फ़ीड नया डेटा दिखाएगा उस से अधिक बार चलाएगा।
</Info>

आप `setPriceFeed` को कॉल करके उस पते को पास करके अपना मूल्य फ़ीड पता भी बदल सकते हैं जिसे आप इंगित (point) करना चाहते हैं।

<Info>
  यदि `PerformUpkeep` पाता है कि मूल्य में कोई परिवर्तन नहीं हुआ है, तो टोकन URI अपडेट नहीं होंगे!।
</Info>

#### 4) अपना पहला टोकन मिंट करें, और रीमिक्स के माध्यम से इसके यूआरआई की जांच करें

यह `gamer_bull.json` होना चाहिए। अगर आप चाहें तो OpenSea पर चेक करें!

#### 5) मॉक वैल्यूज के साथ खेलें

यदि आप दो मॉक का उपयोग कर रहे हैं, तो वैल्यूज के साथ खेलें और `tokenURI` को कॉल करके एनएफटी में परिवर्तन देखें।

#### 6) रिंकीबी पर लाइव चैनलिंक कॉन्ट्रैक्ट पर स्विच करें

जब आप रिंकीबी पर लाइव चैनलिंक कॉन्ट्रैक्ट पर स्विच करने के लिए तैयार हों, तो एनएफटी कॉन्ट्रैक्ट में प्राइस फ़ीड के पते और `vrfCoordinator` को उनके सेटर फ़ंक्शन को कॉल करके अपडेट करें।

#### 7) अपना एनएफटी स्मार्ट कॉन्ट्रैक्ट पंजीकृत करें

इसके बाद, [चैनलिंक कीपर्स रजिस्ट्री](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/) में एक नए "upKeep" के रूप में रिंकीबी पर तैनात किए गए अपने एनएफटी स्मार्ट कॉन्ट्रैक्ट को पंजीकृत करें।

#### 8) [वीआरएफ सब्सक्रिप्शन\*\* बनाएं और फंड करें।](https://docs.chain.link/docs/get-a-random-number/#create-and-fund-a-subscription)

यदि आप लाइव रिंकीबी चैनलिंक वीआरएफ का उपयोग कर रहे हैं तो सुनिश्चित करें कि आप `setVrfCoordinator()` को कॉल करें ताकि आप रिंकीबी पर अपने वीआरएफ मॉक का उपयोग नहीं कर रहे हैं।

यदि आपने इसे लागू नहीं किया है, तो यह आपके सीखने का हिस्सा है, और आप [refrence repo(संदर्भ रेपो)](https://github.com/zeuslawyer/chainlink-dynamic-nft-alchemy/tree/randomness/contracts) की जांच कर सकते हैं।

#### 9) एक या दो घंटे में OpenSea की जाँच करें

इस पर निर्भर करता है की कीमतें कितनी बार बदलती हैं,(और यदि आप तुरंत बदलना चाहते हैं, तो रिंकीबी पर मॉक का उपयोग करना जारी रखें)।

<Info>
  OpenSea मेटाडेटा को कैश (cache) करता है और यह कुछ समय के लिए दिखाई नहीं दे सकता है, भले ही आप `tokenURI` को कॉल कर सकते हैं और अपडेट किए गए मेटाडेटा को देख सकते हैं।

  आप OpenSea पर `force_update` param के साथ अपडेट करने का प्रयास कर सकते हैं लेकिन यह समय पर छवियों को अपडेट नहीं कर सकता है। NFT का नाम कम से कम अपडेट किया जाना चाहिए।
</Info>

## निष्कर्ष

बधाई! आपने एक डायनेमिक NFT को कोड किया है जो वास्तविक-विश्व मूल्य(real-world price) फ़ीड डेटा को दर्शाता है, और क्रिप्टोग्राफ़िक रूप से सिद्ध, छेड़छाड़-प्रतिरोधी यादृच्छिकता(randomness) के साथ डायनेमिक NFT छवियों को तय करता है!

अपने प्रूफ ऑफ नॉलेज (पीओके) टोकन को रिडीम करने के लिए अपना प्रोजेक्ट यहां सबमिट करें: [https://university.alchemy.com/discord](https://university.alchemy.com/discord)

यदि आप इस शक्तिशाली तकनीक के लिए अन्य अद्भुत उपयोग के मामलों का पता लगाना चाहते हैं, तो [चैनलिंक ओरेकल का उपयोग करके डायनेमिक एनएफटी बनाने के 16 तरीके देखें](https://blog.chain.link/create-dynamic-nfts-using-chainlink-oracles/)।
